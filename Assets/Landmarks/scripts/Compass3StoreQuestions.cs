/*    Copyright (C) 2010  Jason Laczko    This program is free software: you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation, either version 3 of the License.    This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License    along with this program.  If not, see <http://www.gnu.org/licenses/>.*/using UnityEngine;using System.Collections;using System.Collections.Generic;using System.Linq;using System;public class Compass3StoreQuestions : ExperimentTask {		public string question = "Imagine you're standing at the {0},    facing the {1}.    Please point to the {2}";	public GameObject parentObject;	public EndListMode EndListBehavior; 	public int size = 9999;	private List<GameObject> obj1;	private List<GameObject> obj2;	private List<GameObject> obj3;			private List<string> texts;	private List<string> answers;	private int current=0;	public string currentText = "";		public bool shuffle=true;			public override void startTask () {		TASK_START();								GameObject[] objs1;		GameObject[] objs2;		GameObject[] objs3;		objs1 = new GameObject[parentObject.transform.childCount];		objs2 = new GameObject[parentObject.transform.childCount];		objs3 = new GameObject[parentObject.transform.childCount];				int i = 0;		foreach (Transform child in parentObject.transform) {			objs1[i] = child.gameObject;			objs2[i] = child.gameObject;			objs3[i] = child.gameObject;			i++;		}				Vector3 o1;		Vector3 o2;		Vector3 o3;				i=1;		string formattedQuestion = "";				 		foreach (GameObject obj1 in objs1) {				             			foreach (GameObject obj2 in objs2) {	 				if 	(obj1 != obj2) {          					foreach (GameObject obj3 in objs3) {													if 	(obj1 != obj3 && obj2 != obj3) {          													formattedQuestion = string.Format(question, obj1.name,obj2.name,obj3.name);														o1 = obj1.transform.position;							o2 = obj2.transform.position;							o3 = obj3.transform.position;														double a = Math.Atan2( o1.z - o2.z , o1.x - o2.x ) * -(180/Math.PI);							double b =  Math.Atan2( o1.z - o3.z , o1.x - o3.x ) * -(180/Math.PI);							//float a = math.atan2( pos[first[i]][3] - pos[second[j]][3] , pos[first[i]][1] - pos[second[j]][1] ) * -RAD;							//float b =  math.atan2( pos[first[i]][3] - pos[third[k]][3] , pos[first[i]][1] - pos[third[k]][1] ) * -RAD;																					//float a = Math.Atan2( pos[first[i]][3] - pos[second[j]][3] , pos[first[i]][1] - pos[second[j]][1] ) * -(180/Math.PI);							//float b =  Math.Atan2( pos[first[i]][3] - pos[third[k]][3] , pos[first[i]][1] - pos[third[k]][1] ) * -(180/Math.PI);										double c = b-a;							if (c < 0)  c = 360+c;										//	 					Debug.Log(formattedQuestion); 	//	 					Debug.Log(c); 		 					texts.Add(c + "\t" + formattedQuestion);		 					i++;						}					}				}			}           		} 		Debug.Log(i); 				string[] tmp = texts.ToArray();					if ( shuffle ) {			Experiment.Shuffle(tmp);		}				texts = tmp.ToList();		texts = texts.GetRange(0,size);		foreach( string txt in texts) {			//Debug.Log(txt);			log.log("TASK_ADD	" + name  + "\t" + this.GetType().Name + "\t" + name  + "\t" + txt,1 );		}				currentText = currentString();			}			public override void TASK_ADD(GameObject go, string txt) {		Debug.Log("ADD  " + txt);		texts.Add(txt);	}		public override void TASK_START()	//public  void Awake()	{		base.startTask();				if (!manager) Start();		texts = new List<string>();			}		public override bool updateTask () {	    return true;	}	public override void endTask() {		TASK_END();	}		public override void TASK_END() {		base.endTask();	}		public override string currentString() {		if (current >= texts.Count) {			return null;		}				return texts[current];	}		public override void incrementCurrent() {		current++;		if (current >= texts.Count && EndListBehavior == EndListMode.Loop) {			current = 0;		}		currentText = currentString();	}}